

# task1

Реалізацію AVL-дерева взято з конспекту і додано функцію для знаходження найбільшого значення

### Алгоритм:
- Почати з кореневого вузла.
- Переміщуватися по правих дочірніх вузлах до тих пір, поки не досягнете вузла без правої дитини.
- Вузол, який не має правої дитини, містить найбільше значення.

### Пояснення функції find_max_value
Функція find_max_value приймає кореневий вузол дерева як аргумент. Вона використовує цикл while, щоб переміщатися вправо по дереву до тих пір, поки не досягне вузла, який не має правої дитини. Цей вузол містить найбільше значення в дереві, яке функція повертає.

# task2

Реалізацію AVL-дерева взято з конспекту і додано функцію для знаходження найменшого значення

### Алгоритм:
- Почати з кореневого вузла.
- Переміщуватися по лівих дочірніх вузлах до тих пір, поки не досягнете вузла без лівої дитини.
- Вузол, який не має лівої дитини, містить найменше значення.

### Пояснення функції find_min_value
Функція find_min_value приймає кореневий вузол дерева як аргумент. Вона використовує цикл while, щоб переміщатися вліво по дереву до тих пір, поки не досягне вузла, який не має лівої дитини. Цей вузол містить найменше значення в дереві, яке функція повертає.

# task3

Реалізацію AVL-дерева взято з конспекту і додано функцію для знаходження суми всіх значень у дереві.

### Пояснення функції find_sum
Функція find_sum приймає кореневий вузол дерева як аргумент. Вона використовує рекурсію для обходу дерева та підсумовування значень вузлів. Якщо поточний вузол є None, функція повертає 0. В іншому випадку функція додає значення поточного вузла до суми значень лівого та правого піддерев, рекурсивно викликаючи саму себе для лівого та правого піддерев.